#!/bin/bash
# Set the environment for the actual app
# such as kubeconfig and app name
# used with direnv

######################
# Standard Library and conf
######################
# The log and error handling
# We still need to use the set command
# because shellcheck does not see them and want use to add
# exit check everywhere
set -Eeuo pipefail
# shellcheck source=bash-library/base
source "$HOME"/bin/bash-library/base

######################
# Main
######################

# Check if the app name is provided
if [ -z "$1" ]; then
    echo "Usage: $0 <app name> <app namespace>"
    exit 1
fi

export KUBE_APP_NAME=$1
export KUBE_APP_NAMESPACE=${2:-$KUBE_APP_NAME}

KUBECONFIG=$HOME/.kube/config-$KUBE_APP_NAME

if [ ! -f "$KUBECONFIG" ]; then
  echo_err "The KUBECONFIG file $KUBECONFIG for the app $KUBE_APP_NAME does not exist"
  echo_err "You will not be able to connect to the cluster"
  exit 1
fi

# Check namespace
KUBECONFIG_NAMESPACE=$(kubectl config view --kubeconfig "$KUBECONFIG" --minify --output 'jsonpath={..namespace}')
if [ "$KUBECONFIG_NAMESPACE" != "$KUBE_APP_NAMESPACE" ]; then
  echo_err "The current context of the KUBECONFIG file $KUBECONFIG does not have the good app namespace (Found $KUBECONFIG_NAMESPACE in place of $KUBE_APP_NAMESPACE)"
  exit;
fi

export KUBECONFIG
if [[ $(uname -a) =~ "CYGWIN" ]];  then
  # kubectl on windows require windows style path
  KUBECONFIG=$(cygpath -aw "$KUBECONFIG")
fi

echo ""
echo "The following kube app env were set:"
echo "KUBECONFIG               : $KUBECONFIG"
echo "KUBE_APP_NAME            : $KUBE_APP_NAME"
echo "KUBE_APP_NAMESPACE       : $KUBE_APP_NAMESPACE"



