#!/bin/bash
# Print the environment for the app
# such as kubeconfig and app name
# used with direnv
# Usage: `eval "$(kube-app-env app-name)"`

######################
# Standard Library and conf
######################
# The log and error handling
# We still need to use the set command
# because shellcheck does not see them and want use to add
# exit check everywhere
set -Eeuo pipefail

# Load echo package
source $(libpath echo.sh)

######################
# Main
######################

# Check if the app name is provided
if [ -z "$1" ]; then
    echo "Usage: $0 <app name> <app namespace>"
    exit 1
fi

export NICO=nico
KUBE_APP_NAME=$1
KUBE_APP_NAMESPACE=${2:-$KUBE_APP_NAME}

KUBECONFIG=$HOME/.kube/config-$KUBE_APP_NAME

if [ ! -f "$KUBECONFIG" ]; then
  echo::err"The KUBECONFIG file $KUBECONFIG for the app $KUBE_APP_NAME does not exist"
  echo::err"You will not be able to connect to the cluster"
  exit 1
fi

# Check namespace
KUBECONFIG_NAMESPACE=$(kubectl config view --kubeconfig "$KUBECONFIG" --minify --output 'jsonpath={..namespace}')
if [ "$KUBECONFIG_NAMESPACE" != "$KUBE_APP_NAMESPACE" ]; then
  echo::err"The current context of the KUBECONFIG file $KUBECONFIG does not have the good app namespace (Found $KUBECONFIG_NAMESPACE in place of $KUBE_APP_NAMESPACE)"
  exit;
fi


if [[ $(uname -a) =~ "CYGWIN" ]];  then
  # kubectl on windows require windows style path
  KUBECONFIG=$(cygpath -aw "$KUBECONFIG")
fi

KUBE_APP_DIRECTORY=$HOME/code/kube-argocd/$KUBE_APP_NAME
if [ ! -d "$KUBE_APP_DIRECTORY" ]; then
  echo::err"The app directory $KUBE_APP_DIRECTORY does not exist"
  exit 1
fi


echo "export KUBECONFIG=$KUBECONFIG"
echo "export KUBE_APP_NAME=$KUBE_APP_NAME"
echo "export KUBE_APP_NAMESPACE=$KUBE_APP_NAMESPACE"
echo "export KUBE_APP_DIRECTORY=$KUBE_APP_DIRECTORY"



