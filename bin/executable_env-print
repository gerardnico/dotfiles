#!/bin/bash
# This script will take an env file
# * print it in a export format
# * retrieve value from a vault if the value has the form: vault:$ENGINE/path/to/secret/field
#
# This script was entirely written by Claude 3.5 Sonnet
# Prompt:
# Can you write a bash script that:
# * will get a env file as first argument called the `input` variable
# * create an `output` variable
# * start a loop to go through each line of the `input` file,
# * filter out  all comments (line that starts with a #),
# * separate the key from the value in 2 variables called respectively `key` and `value`
# * if the value starts with `secret`
#   * get the remaining text in a variable called `secret_path`
#   * make a hashicorp `vault` call to a key value store to get the value where the path is the value of the `secret_path` variable
#   * store the value in the `value` variable
# * add to the `output` variable the line  `export $key=$value`
# * once the loop has finished, echo the whole `output` variable

# Check if an input file is provided
if [ $# -eq 0 ]; then
    echo "Please provide an input file as an argument."
    exit 1
fi

# Assign the first argument to the INPUT variable
INPUT="$1"

# Initialize the OUTPUT variable
OUTPUT=""

# Set the VAULT_PREFIX variable
VAULT_PREFIX="vault:"

# Function to trim leading and trailing whitespace
trim() {
    local VAR="$*"
    # Remove leading whitespace characters
    VAR="${VAR#"${VAR%%[![:space:]]*}"}"
    # Remove trailing whitespace characters
    VAR="${VAR%"${VAR##*[![:space:]]}"}"
    printf '%s' "$VAR"
}

# Process each line in the INPUT file
while IFS= read -r LINE; do
    # Skip comments (lines starting with #)
    if [[ $LINE =~ ^[[:space:]]*#.*$ ]]; then
        continue
    fi

    # Separate KEY and VALUE
    if [[ $LINE =~ ^([^=]+)=(.*)$ ]]; then
        KEY=$(trim "${BASH_REMATCH[1]}")
        KEY=${KEY^^} # Convert KEY to uppercase
        VALUE=$(trim "${BASH_REMATCH[2]}")

        # Check if VALUE starts with VAULT_PREFIX
        if [[ $VALUE == $VAULT_PREFIX* ]]; then
            # Extract the SECRET_PATH
            SECRET_PATH=${VALUE#$VAULT_PREFIX}
            SECRET_PATH=$(trim "$SECRET_PATH")

            # Extract the MOUNT (first part of the path)
            IFS='/' read -r MOUNT REST <<< "$SECRET_PATH"

            # Extract the FIELD (last part of the remaining path)
            IFS='/' read -ra PATH_PARTS <<< "$REST"
            FIELD=${PATH_PARTS[-1]}

            # Remove the FIELD from the SECRET_PATH
            SECRET_PATH=${REST%/$FIELD}

            # Make a Vault call to get the actual value using the extracted MOUNT
            if ! VALUE=$(vault kv get -mount="$MOUNT" -field="$FIELD" "$SECRET_PATH"); then
                echo "Error: Failed to retrieve secret from Vault for mount: $MOUNT, path: $SECRET_PATH, field: $FIELD" >&2
                exit 1
            fi
        fi

        # Add the processed line to the OUTPUT
        OUTPUT+="export $KEY=$VALUE"$'\n'
    fi
done < "$INPUT"

# Echo the entire OUTPUT
echo "$OUTPUT"