#!/bin/bash

##########################################
# Standard/Library function
##########################################

# Strict flag
# e - Exit if any error
# u - Treat unset variables as an error when substituting
# o pipefail - the return value of a pipeline is the status of the last command to exit with a non-zero status or zero if no command exited with a non-zero status
# E - the ERR trap is inherited by shell functions
set -Eeuo pipefail


CLI_NAME=$(basename "$0") # Name of the cli

# Echo a message
function echo_log() {

  echo -e "$CLI_NAME: ${1:-}"

}

# Print the error message $1
function echo_err() {
  RED='\033[0;31m'
  NC='\033[0m' # No Color
  #(>&2 echo -e "${RED}$1${NC}")
  echo_log "${RED}$1${NC}"
}




# Define the error handling function
error_handler() {
    local err=$?
    local line=$1
    local command="$2"
    echo_err "Error on ${BASH_SOURCE[1]} line $line"
    echo_err ""
    echo_err "Command '$command' exited with status $err."

    # CallStack with FUNCNAME
    # The FUNCNAME variable exists only when a shell function is executing.
    # The last element is `main` with the current script being 0

    # If FUNCNAME has only one element, it's the main script
    # No stack print needed
    if [ ${#FUNCNAME[@]} = 1 ]; then
        return;
    fi
    echo_err ""
    echo_err "Call Stack:"
    for ((i=0; i < ${#FUNCNAME[@]}; i++)) do
        echo_err "  $i: ${BASH_SOURCE[$i]}#${FUNCNAME[$i]}:${BASH_LINENO[$i]}"
    done
}


## A trap on ERR, if set, is executed before the shell exits.
# Because we show the $LINENO, we need to pass a command to the trap and not a function otherwise the line number would be not correct
trap 'error_handler "$LINENO" "${BASH_COMMAND}"' ERR
